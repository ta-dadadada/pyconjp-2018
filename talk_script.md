## diff 最小化原理で導く Zen of Python のトークスクリプト

はじめまして、 多田 です。
今日は {} というタイトルでお話しします。

## 自己紹介

はじめに少しだけ自己紹介をします。
改めまして、いい生活という会社でサーバサイドエンジニアをやっている多田といいます。
普段は Python で WebAPI の開発をしています。
入社して2年目の、まだまだ勉強中の身ですが、このような機会をいただきまして戦々恐々としています。

## はじめに

それでは早速本題に入ります。

### talk の主題

ざっくりいうと今日は *Python* を書こう、ということでお話していきたいと思います。
キーワードとしてはこのあたりになります。
Abstruct には「ソフトウェア品質とは何かについて語る」、
という感じのかなり詩的なことを書いたんですが、
ちょっと再編成しまして、 Pythonic なコードを作っていくにはどうすればいいだろう、という話になる予定です。
アブスト詐欺になっていたらすみません。

### OCP: Open/Closed Principle

いきなりですが、 OCP という設計原理について説明します。
これは Open/Closed Priciple 、日本語だと「開放/閉鎖原則」と訳されますが、
オブジェクト指向やデザインパターンの根底にある基本的な考え方のひとつです。

### Meyer 氏曰く

これを提唱したのは、かの有名なバートランド・メイヤー氏です。
氏曰く、

> モジュールは拡張に対して開いて (Open) おり，修正に対して閉じて (Closed) いなければならない

ということです。
一見すると、対立する言葉で似たような言葉を説明しているので、ちょっと意味が取りにくいです。

### OCP が言っていること

ざっくりと OCP が主張するところをまとめるのならば、
既存のソフトウェアに対して、何らかの機能追加を行うときには、
追加したいものを追加したい部分だけ実装するだけで済み、
既存実装やモジュールの呼び出し箇所には修正が入らないようにしましょう、
また、そうできるようにはじめからちゃんと設計してきましょう、ということです。
言っていることはなんとなく理解できるかと思います。

### OCP の良い例

OCP がどのように実現されるかというと、代表的にはクラスのインターフェイス、という形で顕在化します。
例えば、scikit-learn の API ``fit()`` や ``predict()`` は、
すべてのクラスで共通のインターフェイスを持っています。
このときは新しく ``Predictor`` クラスを増やしたとしても、
そのクラスのキモになる部分の使い方は変わりませんし、
また、それができるようにうまく設計されています。

### OCP の目指すもの

具体的な例を見た後で、話が一旦抽象的かつ詩的なところに戻りますが、
プログラマの視点から眺めると、結果的にはOCP の目指すところは
プログラムの改修にかかるコストを **ライフタイム** を通して最小化する
ということになるのではないかと思います。

### How to OCP

ちょっと言いすぎな言い方をすれば、結局のところ OCP というのは、
将来を含めてなるべくコーディングの手間を減らしましょうという考え方です。

解きほぐすとこれは、 diff が小さくなるように作れるのがよいソフトウェアだということになります。
これを今日は **diff 最小化原理** と呼びたいと思います。仮説というか、造語のはずです。

### diff 最小化原理

なぜこれを要するに、修正の diff が最小になるようにプログラムしていくことで、
OCP はもちろん、今回のゴールである `Zen of Python` に従っているような、
最適解に辿りつけるんじゃないかな、というのが今回の主張です。

## Python で diff を少なくする方法

というわけで Python で diff を減らすための実例集を紹介します。

### カンマ

はじめはしょぼい、よくある例です。
python ではリストやdict の最後の要素の後ろにカンマがあっても許されることを利用します。
ここではモジュールのインポートですが、結論から言うと下の縦に並べる例が good です。
理由はモジュールを増減させたときの diff を見れば明らかで、

### カンマ②

縦に並べておくと変更した場所がひと目でわかります。
お尻の ``,`` が大事で、あらかじめつけておかないとカンマの分 diff が2行でてしまいます。

### 要素の取得①

これもよく見る光景ですが、 python の辞書が `get` をサポートしているのをいいことに、
`get` でアクセスして、 `None` かどうか判定しているうえに、エラーを raise している

### 要素の取得②

key が無いことが以上なら、最初から key でアクセスして、 KeyError でるに任せるべきです。
こちらのほうが圧倒的に簡潔で意味も通りやすい。
python の例外処理は十分に早いので実行速度を心配する必要はないです。

### デコレータ①

また、 python syntax を利用した例としてデコレータの活用も紹介します。

ログインを必須とするリソースとそうでないものが入り乱れているとき、
いちいちメソッドの中に条件分岐を書き込むのは手間です。

### デコレータ②

デコレータをうまく定義しておけば、メソッド定義に1行追加するだけです。
簡潔で、条件分岐もなく、なにより視認性が高いです。

### Mixin

Mixin は python の中で最も特徴的な機能のひとつです。

例のようにベースクラスと Mixin の継承定義されるクラスはよくあるやり方で、
機能をうまく直交化させている良い例です。
機能追加の場合は、それ用の Mixin を作成して、継承することで新たな機能を持ったクラスを作り出すことができます。
このときの diff は Mixin の定義、つまり追加したい処理部分と、継承元に Mixin を追加する①行のみです。

## Zen of Python にたどり着く

というわけでここまで「python で diff を小さくする実践例」をご紹介してきましたが、
ここで talk のテーマにもした Zen of Python について思い返してみましょう。

### Zen of Python ってなんだっけ？

Zen of Python は Tim Peters 氏が示した Python 設計 19 の指針です。
`import this` のイースターエッグでも有名ですね。

### 恣意的にいくつか抜粋（意訳付）

ぼくが特に好きなものはこの辺です。

### ここまでやってきたこと

今回のトークで紹介したのは、結局、
python の言語機能、 syntaxを最大限活用して、
diff を最小化しながら実装をしていこう、ということでした。

### diff 最小化原理のご利益

逆説的ではあるんですが、そういう方針でコードをかく以上、
python の言語機能をフル活用せざるをえないわけなので、
自然と **Zen of Python** に従っていきます。

### diff 最小化原理のご利益②

ここまで納得していただけたかはわかりませんが、個人的に思うこととして、
**diff をなるべく小さくする** という明快な目標のほうが
*チームとして* ゴールを目指しやすいんじゃないかな、というのをちょっと思っています。
「Zen of Python」や「デザインパターン」などの考え方を指針にしてしまうと、
抽象的ですし、人によって習熟度が全然違います。
目標を共有するという意味で、diff を最小化するというのは、
すごくわかりやすいんじゃないかと思っています

### まとめ

発表はこれで以上です。


